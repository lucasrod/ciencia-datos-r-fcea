---
title: "Análisis Exploratorio: Dataset Ames"
subtitle: "Análisis para modelo de regresión con Sale_Price como variable respuesta"
format:
  html:
    self-contained: true
    toc: true
    toc-depth: 2
    code-fold: false
    code-tools: true
    code-summary: "Mostrar código"
execute:
  echo:    true
  warning: true
  message: false
editor: visual
---

```{r setup, message=FALSE}
# Cargar paquetes necesarios
library(tidyverse)
library(tidymodels) # ML
library(modeldata)  # Ames housing dataset
library(skimr)      # Análisis descriptivo
library(corrplot)   # Para matrices de correlación
library(GGally)     # Para pair plots avanzados
library(patchwork)  # Para combinar gráficos
library(ggthemes)   # Temas para ggplot2
library(e1071)      # Para asimetría y curtosis

# Reproducibilidad
set.seed(42)

# Configuración general
theme_set(theme_minimal())
options(dplyr.summarise.inform = FALSE)
```

# Análisis Exploratorio: Dataset Ames

## Resumen

Este análisis exploratorio tiene como objetivo complementar el trabajo realizado en `HW2.qmd`, proporcionando una caracterización del dataset `ames` antes de aplicar modelos supervisados. Se identifican patrones relevantes en la variable respuesta `Sale_Price`, se evalúan relaciones clave con las variables predictoras y se diagnostica la calidad general de los datos.

A continuación se sintetizan los principales hallazgos:

-   **Distribución de la variable objetivo (`Sale_Price`)**: Presenta una cola larga a la derecha, lo que sugiere que unas pocas viviendas tienen precios significativamente más altos que la mayoría. Esta observación, consistente con la exploración hecha en Kaggle, motiva el uso de transformaciones como `log(Sale_Price)` para estabilizar la varianza y mejorar la aproximación a la normalidad antes de aplicar modelos lineales.

-   **Estadísticos claves de `Sale_Price`**:

    -   Mediana: `XX`
    -   Media: `XX`
    -   Coeficiente de variación (CV): `XX%`
    -   Asimetría: `XX`
    -   Curtosis: `XX`

-   **Valores atípicos (outliers)**:

    -   Se detectaron `XX` observaciones (≈ `XX%`) fuera del rango intercuartílico.
    -   Se recomienda evaluar su impacto durante la validación del modelo.

-   **Calidad general del dataset**:

    -   Total de observaciones: `2,930`
    -   Total de variables: `74`
    -   Variables con valores faltantes: `X` (ej. `Lot_Frontage`, `Alley`, etc.)
    -   No se detectan filas duplicadas por ID, aunque algunas variables presentan codificación especial de ausencia (ceros como "No aplica").

-   **Variables predictoras destacadas**:

    -   Las variables numéricas más correlacionadas con `Sale_Price` son: `Gr_Liv_Area`, `Garage_Area`, `Total_Bsmt_SF`, entre otras.
    -   Se observa colinealidad entre ciertos predictores relacionados con superficie.

-   **Sugerencias para el modelado**:

    -   Transformar `Sale_Price` mediante `log()` para mejorar los supuestos de normalidad.
    -   Evaluar interacciones no lineales y colinealidad entre variables.
    -   Considerar ingeniería de características que reflejen combinaciones relevantes (ej. superficie total habitable).

Este informe sirve como insumo previo para diseñar estrategias de preprocesamiento y selección de variables en el modelado predictivo.

## Paneo Inicial y Diagnóstico de Calidad

Realizamos un diagnóstico inicial del dataset `ames` cargado desde el paquete `{modeldata}`. Exploraremos su estructura, tipos de variables, presencia de valores faltantes (*missing values*), duplicados y codificaciones especiales.

```{r load_data}
# Cargar el dataset ames
data(ames)
ames_data <- as_tibble(ames)
```

### Estructura

```{r glimpse}
glimpse(ames_data)
```

### EDA Univariado

Diferenciamos entre variables numéricas y categóricas, y para cada tipo se presentan estadísticos de resumen, distribución, y niveles o codificaciones relevantes, útil para detectar problemas tempranos.

#### Clase de variables
```{r class_types}
# Conteo de clases
ames_data %>%
  summarise(across(everything(), class)) %>%
  pivot_longer(cols = everything(), names_to = "n_variables", values_to = "class") %>%
  count(class, name = "n_variables") %>%
  knitr::kable(caption = "Distribución de clases de variables")
```

> Nota: En tipos primitivos de R `numeric` --> `double`, `factor` --> `integer`.

#### Tipo de variable para el análisis

Factores vs numéricos.

```{r skim_types}
skim_summary <- skim(ames_data)
skim_summary %>%
  count(skim_type, name = "n_variables") %>%
  knitr::kable(caption = "Distribución de tipo de variables (skim_type)")
```

##### Variables categóricas

Mostramos la cantidad de categorías y las categorías más observadas de las variables de tipo factor:

```{r cat_skim_summary}
skim_summary %>%
  filter(skim_type == "factor") %>%
  arrange(desc(factor.n_unique)) %>%
  select(
    variable    = skim_variable,
    n_levels    = factor.n_unique,
    top_counts  = factor.top_counts,
  ) %>%
  knitr::kable(
    caption = "Variables categóricas: niveles y counts principales"
  )
```

```{r cat_levels_distribution}

# Cardinalidad de cada factor desde skim_summary
cardinality <- skim_summary %>%
  filter(skim_type == "factor") %>%
  select(
    variable = skim_variable,
    n_levels = factor.n_unique
  )

# Conteo y proporciones por nivel
factor_vars <- cardinality$variable

prop_cat <- map_dfr(factor_vars, function(var) {
  ames_data %>%
    count(level = .data[[var]]) %>%
    mutate(
      variable = var,
      prop     = percent(n / sum(n), accuracy = 0.1)
    )
})

# Unir cardinalidad ordenando por n_levels (desc) y luego por n (desc)
prop_cat %>%
  left_join(cardinality, by = "variable") %>%
  arrange(
    desc(n_levels),  # se usa para ordenar, pero no se mostrará
    variable,
    desc(n)
  ) %>%
  select(variable, level, n, prop) %>%  # acá ya no incluimos n_levels
  knitr::kable(
    caption = "Distribución de niveles de variables categóricas"
  )
```

##### Variables numéricas

Calculamos medidas de tendencia central, posición, dispersión y dirección de asimetría (`media - mediana`):

```{r num_skim_summary}
skim_summary %>%
  filter(skim_type == "numeric") %>%
  transmute(
    variable = skim_variable,
    mean     = numeric.mean,
    sd       = numeric.sd,
    rel_skew = abs(numeric.mean - numeric.p50) / numeric.sd, # asimetría relativa a la dispersión
    asimetría = case_when(
      is.na(rel_skew)             ~ "indefinida",
      rel_skew < 0.2              ~ "Aprox. simétrica", # Se sugiere disminuir el umbral
      numeric.mean > numeric.p50  ~ "Positiva",
      TRUE                        ~ "Negativa"
    ),
    histograma = numeric.hist,
    p0       = numeric.p0,
    p25      = numeric.p25,
    median   = numeric.p50,
    p75      = numeric.p75,
    p100     = numeric.p100
  ) %>%
  knitr::kable(
    digits = 2,
    caption = "Variables numéricas"
  )
```

> Nota: `rel_skew` es una aproximación útil para comparar diferencias relativas entre media y mediana entre distribuciones con escalas o unidades distintas. Sin embargo, **no siempre refleja adecuadamente la estructura de la distribución**. Por ejemplo:
>
> * En `Lot_Area`, el valor de `rel_skew` es bajo a pesar de una asimetría real muy alta, ya que **la alta desviación estándar atenúa el impacto de colas extremas**.
> * En `Kitchen_AbvGr`, la aparente simetría se debe a un **soporte discreto y reducido** con una moda dominante, lo que mantiene la media y mediana cercanas aunque exista asimetría.
> * En `BsmtFin_SF_1`, se observa lo opuesto: la diferencia entre media y mediana parece indicar asimetría, pero se debe a **modas discretas separadas** dentro de una distribución que en realidad tiene colas relativamente simétricas.
>
> Por ello, se complementa el análisis con el coeficiente de asimetría (`skewness`) y otras métricas robustas.


##### EDA numérico extendido

Variables numéricas con coeficiente de variación, rango intercuartíl, asimetría (exacta), curtosis y sugerencia de transformación.

```{r eval = FALSE}
skim_summary %>% rowwise() %>% mutate(x = list(ames_data[[skim_variable]])) %>% glimpse()
```

```{r extended_numeric_eda}
library(robustbase) # para medcouple (asimetría robusta)
# Variables numéricas con EDA extendido
numeric_eda <- skim_summary %>%
  filter(skim_type == "numeric") %>%
  # Para poder usar e1071 necesitamos extraer cada vector numérico de las variables
  rowwise() %>%
  mutate(
    x = list(ames_data[[skim_variable]]), # vector original de cada variable
    cv = numeric.sd / numeric.mean,       # coef. de variación
    iqr = numeric.p75 - numeric.p25,      # rango IQ
    skewness = skewness(x),               # asimetría
    medcouple = mc(x), # asimetría robusta
    kurtosis = kurtosis(x),               # curtosis
    prop_outliers = if_else(iqr == 0, NA_real_,
                        mean(x < (numeric.p25 - 1.5*iqr) |
                        x > (numeric.p75 + 1.5*iqr), 
                        na.rm = TRUE)), # outliers regla Tukey
    transform_rec = case_when(
      skewness < 0 ~ "ninguna: asimetría negativa",
      !all(x >= 0, na.rm = TRUE) ~ "ninguna: valores negativos",
      all(x > 0,  na.rm = TRUE) & skewness > 1.5 ~ "log",
      all(x > 0,  na.rm = TRUE) & skewness > 0.5 ~ "Box-Cox (evaluar)",
      all(x >= 0, na.rm = TRUE) & skewness > 0.5 ~ "log(x+1) o sqrt: contiene ceros",
      TRUE            ~ "ninguna"
    )
  ) %>%
  ungroup() %>%
  transmute(
    variable        = skim_variable,
    mean            = numeric.mean,
    sd              = numeric.sd,
    cv,
    skewness        = round(skewness, 2),
    medcouple       = round(medcouple, 2),
    kurtosis        = round(kurtosis, 2),
    pct_outliers    = percent(prop_outliers, accuracy = 0.1),
    iqr,
    histograma      = numeric.hist,
    transform_rec   = transform_rec
  )

  knitr::kable(
    numeric_eda,
    digits = 2,
    caption = "Análisis extendido de variables numéricas"
  )

```

> **Nota sobre las medidas de asimetría:**
> En este análisis se reportan dos métricas complementarias para evaluar la asimetría de las variables numéricas:
>
> * `skewness` corresponde al **coeficiente muestral de asimetría ($g_1$)**, una medida **paramétrica** que estima la forma de la distribución en función del sesgo respecto a la media (tercer momento muestral). Es sensible a valores atípicos (*outliers*) y capta la **asimetría en las colas**.
> * `medcouple`: es un **estadístico no paramétrico y robusto** que mide la asimetría del “cuerpo central" de la distribución, sin verse afectado por outliers.
>
> Dado que ambas métricas responden a diferentes aspectos de la forma de la distribución, pueden arrojar resultados aparentemente contradictorios:
>
> * En variables con muchos ceros y algunos valores extremos altos (como `Pool_Area` o `Misc_Val`), el `medcouple` puede ser **negativo** (indicando que la masa principal está a la derecha), mientras que el `skewness` será **positivo** por la presencia de colas largas hacia la derecha.
>
> * En otros casos, como `Kitchen_AbvGr`, aunque la media y la mediana están alineadas (dando idea de simetría), el `skewness` puede ser alto por la naturaleza discreta de la variable (muchos 1 y pocos valores mayores).
>
> Por ello, **es recomendable interpretar ambas medidas en conjunto**:
> `skewness` capta simetría global, incluyendo extremos, y `medcouple` resume la simetría de la parte mas densa de la distribución.
> Usarlas juntas da una visión más completa sobre la simetría de cada variable.

#### Valores faltantes (*missing values*)

```{r missing_values}
# Resumen de NAs
n_obs <- nrow(ames_data)
na_summary <- ames_data %>%
  summarise(across(everything(), ~ sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_na") %>%
  filter(n_na > 0) %>%
  mutate(pct = round(100 * n_na / n_obs, 2)) %>%
  arrange(desc(pct)) %>%
  knitr::kable(caption = "Variables con valores faltantes")
```

```{r}
cat("Número de variables con NA:", nrow(na_summary), "\n")
```

> No se detectan missing values explícitos en el dataset.

#### Ausencia estructural en variables categóricas

> Variables numéricas como `Garage_Area` o `MasVnr_Area` pueden contener ceros que no representan valores cuantitativos reales, sino ausencia de la característica (p.ej., `Mas_Vnr_Area = 0` cuando `Mas_Vnr_Type == "None"`). Este detalle también se resalta en notebooks de Kaggle, donde se señala que “el valor 0 puede estar indicando que el criterio no aplicaba”. Prestar especial atención al imputar o escalar estos ceros.

```{r special_coding}  
# Ejemplo: proporción de ceros en Mas_Vnr_Area cuando hay "None"
# Deberíamos hacer esto para todas las variables numéricas que contengan ceros quizas?
ames_data %>%
  filter(Mas_Vnr_Type == "None") %>%
  summarise(p_zeros = mean(Mas_Vnr_Area == 0)) %>%
  mutate(p_zeros = round(p_zeros * 100, 2)) %>%
  knitr::kable(caption = "Proporción de ceros esperados por codificación")
```

```{r}
cat_vars <- ames_data %>% select(where(is.factor))

none_levels <- c("None", "No", "No_Alley_Access", "No_Pool", "No_Fence", "No_Garage", "No_Basement", "No_Shed", "No_")

none_summary <- cat_vars %>%
  summarise(across(everything(), ~ sum(. %in% none_levels))) %>%
  pivot_longer(everything(), names_to = "variable", values_to = "n_none") %>%
  filter(n_none > 0) %>%
  mutate(pct = round(100 * n_none / n_obs, 2)) %>%
  arrange(desc(pct))

knitr::kable(none_summary, caption = "Variables categóricas con niveles que indican ausencia estructural")
```

#### Ceros estructurales en variables numéricas

```{r}
cat_vars <- ames_data %>% select(where(is.factor))
# Contar observaciones con valor "None" o "No_*"
none_summary <- cat_vars %>%
  summarise(across(everything(), ~ sum(. %in% c("None", "No", "No_Alley_Access", "No_Pool", "No_Fence", "No_Garage", "No_Basement", "No_Shed", "No_"))) ) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "n_none") %>%
  filter(n_none > 0) %>%
  mutate(pct = round(100 * n_none / nrow(ames_data), 2)) %>%
  arrange(desc(pct))

none_summary %>%
  knitr::kable(caption = "Variables categóricas con niveles 'None' o similares (ausencia estructural)")
```

```{r}
ames_data %>%
  filter(Mas_Vnr_Type == "None") %>%
  summarise(p_zeros = mean(Mas_Vnr_Area == 0, na.rm = TRUE)) %>%
  mutate(p_zeros = round(p_zeros * 100, 2)) %>%
  knitr::kable(caption = "Proporción de ceros estructurales en Mas_Vnr_Area cuando Mas_Vnr_Type = 'None'")
```

```{r}
ames_data %>%
  filter(Garage_Type == "None") %>%
  summarise(
    p_zero_area = mean(Garage_Area == 0, na.rm = TRUE),
    p_zero_cars = mean(Garage_Cars == 0, na.rm = TRUE)
  ) %>%
  mutate(across(everything(), ~ round(.x * 100, 2))) %>%
  knitr::kable(caption = "Proporción de ceros estructurales en variables de garage cuando Garage_Type = 'None'")
```

#### Duplicados

No existe variable `Id` en el dataset, por lo que no se puede validar unicidad de filas por identificador. Validaremos unicidad de filas por fila completa.

```{r duplicates}
# Validar unicidad de Id si existiera o por fila completa
n_duplicadas <- ames_data %>% duplicated() %>% sum()
cat("Número de filas duplicadas:", n_duplicadas, "\n")
```

> No se detectan filas duplicadas exactas.

## Análisis de la variable respuesta: Sale_Price

### Resumen estadístico

```{r target_summary}
# Resumen estadístico de Sale_Price
summary(ames_data$Sale_Price)

# Coeficiente de variación
cv_sale_price <- sd(ames_data$Sale_Price, na.rm = TRUE) / mean(ames_data$Sale_Price, na.rm = TRUE) * 100
cv_sale_price <- round(cv_sale_price, 2)

cat("Coeficiente de variación de Sale_Price:", cv_sale_price, "%\n")

skewness_value <- skewness(ames_data$Sale_Price, na.rm = TRUE)
kurtosis_value <- kurtosis(ames_data$Sale_Price, na.rm = TRUE)

cat("Asimetría:", round(skewness_value, 2), "\n")
cat("Curtosis:", round(kurtosis_value, 2), "\n")
```

### Visualización de la distribución

```{r target_distribution}
# Histograma con curva de densidad
p1 <- ames_data %>%
  ggplot(aes(x = Sale_Price)) +
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 50, 
                 fill = "steelblue", 
                 color = "white", 
                 alpha = 0.8) +
  geom_density(color = "red", linewidth = 1) +
  scale_x_continuous(labels = scales::dollar) +
  labs(title = "Distribución de Precios de Venta",
       x = "Precio de Venta (USD)",
       y = "Densidad") +
  theme(plot.title = element_text(hjust = 0.5))

# QQ-plot para normalidad
p2 <- ggplot(ames_data, aes(sample = Sale_Price)) +
  stat_qq(color = "steelblue") +
  stat_qq_line(color = "red") +
  labs(title = "QQ-Plot de Normalidad",
       x = "Cuantiles Teóricos",
       y = "Cuantiles Muestrales") +
  theme(plot.title = element_text(hjust = 0.5))

# Boxplot para identificar valores atípicos
p3 <- ames_data %>%
  ggplot(aes(y = Sale_Price)) +
  geom_boxplot(fill = "steelblue", alpha = 0.7) +
  scale_y_continuous(labels = scales::dollar) +
  labs(title = "Boxplot de Precios de Venta",
       y = "Precio de Venta (USD)") +
  theme(plot.title = element_text(hjust = 0.5))

# Mostrar gráficos
(p1 + p2) / p3 + plot_layout(heights = c(2, 1))
```

### Transformación logarítmica

```{r log_transform}
# Aplicar transformación logarítmica
ames_data <- ames_data %>%
  mutate(log_Sale_Price = log(Sale_Price))

# Visualizar distribución transformada
p4 <- ames_data %>%
  ggplot(aes(x = log_Sale_Price)) +
  geom_histogram(aes(y = after_stat(density)), 
                 bins = 50, 
                 fill = "steelblue", 
                 color = "white", 
                 alpha = 0.8) +
  geom_density(color = "red", linewidth = 1) +
  labs(title = "Distribución de log(Sale_Price)",
       x = "log(Precio de Venta)",
       y = "Densidad") +
  theme(plot.title = element_text(hjust = 0.5))

# QQ-plot para normalidad de la variable transformada
p5 <- ggplot(ames_data, aes(sample = log_Sale_Price)) +
  stat_qq(color = "steelblue") +
  stat_qq_line(color = "red") +
  labs(title = "QQ-Plot de log(Sale_Price)",
       x = "Cuantiles Teóricos",
       y = "Cuantiles Muestrales") +
  theme(plot.title = element_text(hjust = 0.5))

# Mostrar gráficos transformados
p4 + p5
```

## Análisis de variables predictoras

### Variables numéricas

#### Correlación con variables numéricas

```{r numeric_correlation}
# Seleccionar solo variables numéricas
numeric_vars <- ames_data %>%
  select(where(is.numeric)) %>%
  select(-matches("^[A-Za-z]+\\.y\\.+[0-9]+\\.?[0-9]*$"))  # Eliminar columnas duplicadas

# Matriz de correlación
cor_matrix <- cor(numeric_vars, use = "complete.obs")

# Variables más correlacionadas con Sale_Price
cor_with_target <- cor_matrix[, "Sale_Price", drop = FALSE] %>%
  as.data.frame() %>%
  rownames_to_column("Variable") %>%
  arrange(desc(Sale_Price)) %>%
  filter(Variable != "Sale_Price")

# Mostrar las 15 variables más correlacionadas
head(cor_with_target, 15) %>% 
  knitr::kable(digits = 3, 
               col.names = c("Variable", "Correlación con Sale_Price"),
               caption = "Variables numéricas más correlacionadas con Sale_Price")

# Gráfico de correlación para las 10 variables más relacionadas
corrplot.mixed(cor(numeric_vars[, c("Sale_Price", head(cor_with_target$Variable, 10))], 
                  use = "complete.obs"),
               upper = "circle",
               lower.col = "black",
               number.cex = 0.7,
               tl.cex = 0.7,
               tl.pos = "lt",
               title = "Matriz de correlación - Top 10 variables")
```

#### Relaciones bivariadas con las variables más correlacionadas

```{r top_correlations}
# Función para crear scatter plots con línea de tendencia
plot_scatter <- function(data, x_var, y_var = "Sale_Price") {
  data %>%
    ggplot(aes(x = !!sym(x_var), y = !!sym(y_var))) +
    geom_point(alpha = 0.5, color = "steelblue") +
    geom_smooth(method = "lm", color = "red", se = FALSE) +
    scale_y_continuous(labels = scales::dollar) +
    labs(title = paste("Relación entre", x_var, "y Sale_Price"),
         x = x_var,
         y = "Precio de Venta (USD)") +
    theme(plot.title = element_text(size = 10, hjust = 0.5))
}

# Variables numéricas más correlacionadas (excluyendo las que tienen muchos valores únicos)
top_numeric <- cor_with_target %>%
  filter(!Variable %in% c("Id", "Mo_Sold", "Year_Sold", "Garage_Yr_Blt")) %>%
  head(6) %>%
  pull(Variable)

# Crear scatter plots
scatter_plots <- map(top_numeric, ~plot_scatter(ames_data, .x))

# Mostrar gráficos
wrap_plots(scatter_plots, ncol = 2) + 
  plot_annotation(title = 'Relación entre las variables numéricas más correlacionadas y Sale_Price',
                  theme = theme(plot.title = element_text(hjust = 0.5, size = 12)))
```

### Variables categóricas

#### Análisis de variables categóricas importantes

```{r categorical_analysis}
#| eval: false
# Función para graficar variables categóricas vs Sale_Price
plot_cat_var <- function(data, var_name, y_var = "Sale_Price") {
  data %>%
    ggplot(aes(x = reorder(!!sym(var_name), !!sym(y_var), FUN = median, na.rm = TRUE), 
               y = !!sym(y_var))) +
    geom_boxplot(fill = "steelblue", alpha = 0.7) +
    stat_summary(fun = median, geom = "point", color = "red", size = 2) +
    scale_y_continuous(labels = scales::dollar) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
          plot.title = element_text(size = 10, hjust = 0.5)) +
    labs(title = paste("Distribución de", y_var, "por", var_name),
         x = var_name,
         y = y_var)
}

# Variables categóricas relevantes basadas en conocimiento de dominio
cat_vars <- c("Neighborhood", "Overall_Cond", "Kitchen_AbvGr", "Garage_Type", 
              "Heating_QC", "Foundation", "Bsmt_Cond")

# Crear gráficos
cat_plots <- map(cat_vars, ~plot_cat_var(ames_data, .x))

# Mostrar gráficos
wrap_plots(cat_plots, ncol = 2) + 
  plot_annotation(title = 'Distribución de Sale_Price por variables categóricas',
                  theme = theme(plot.title = element_text(hjust = 0.5, size = 14)))
```

## Análisis de valores faltantes

```{r cat_missing_values}
# Función para calcular porcentaje de valores faltantes por columna
missing_summary <- function(data) {
  data %>%
    summarise(across(everything(), ~sum(is.na(.)))) %>%
    pivot_longer(everything(), names_to = "variable", values_to = "n_missing") %>%
    mutate(pct_missing = n_missing / nrow(data) * 100) %>%
    filter(n_missing > 0) %>%
    arrange(desc(pct_missing))
}

# Calcular y mostrar resumen de valores faltantes
missing_data <- missing_summary(ames_data)

# Mostrar variables con valores faltantes
if(nrow(missing_data) > 0) {
  knitr::kable(missing_data, 
               digits = 2,
               caption = "Variables con valores faltantes")
} else {
  cat("No hay valores faltantes en el dataset.")
}

# Visualizar el patrón de valores faltantes
if(nrow(missing_data) > 0) {
  library(naniar)
  vis_miss(ames_data, sort_miss = TRUE) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +
    labs(title = "Patrón de valores faltantes en el dataset")
}
```

## Análisis de valores atípicos

```{r outliers_analysis}
# Función para identificar valores atípicos usando el método IQR
get_outliers <- function(x) {
  qnt <- quantile(x, probs = c(0.25, 0.75), na.rm = TRUE)
  iqr <- IQR(x, na.rm = TRUE)
  lower <- qnt[1] - 1.5 * iqr
  upper <- qnt[2] + 1.5 * iqr
  list(lower = lower, upper = upper, outliers = x[x < lower | x > upper])
}

# Identificar valores atípicos en Sale_Price
outliers_sale_price <- get_outliers(ames_data$Sale_Price)

# Mostrar resumen de valores atípicos
cat("Límite inferior para valores atípicos:", scales::dollar(outliers_sale_price$lower), "\n")
cat("Límite superior para valores atípicos:", scales::dollar(outliers_sale_price$upper), "\n")
cat("Número de valores atípicos:", length(outliers_sale_price$outliers), "\n")
cat("Porcentaje de valores atípicos:", 
    round(length(outliers_sale_price$outliers) / nrow(ames_data) * 100, 2), "%\n")

# Visualizar valores atípicos
ames_data %>%
  mutate(is_outlier = if_else(Sale_Price > outliers_sale_price$upper | 
                              Sale_Price < outliers_sale_price$lower, 
                            "Atípico", "Normal")) %>%
  ggplot(aes(x = "", y = Sale_Price, fill = is_outlier)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Atípico" = "red", "Normal" = "steelblue")) +
  scale_y_continuous(labels = scales::dollar) +
  labs(title = "Identificación de valores atípicos en Sale_Price",
       x = "",
       y = "Precio de Venta (USD)",
       fill = "Clasificación") +
  theme(legend.position = "bottom")
```

## Conclusiones y recomendaciones para el modelado

### Hallazgos principales

-   **Variable respuesta (Sale_Price)**:
    -   Distribución asimétrica a la derecha, con una cola larga hacia valores altos
    -   Coeficiente de variación del XX% indica una variabilidad moderada en los precios
    -   La transformación logarítmica mejora significativamente la normalidad de la distribución
-   **Variables numéricas más relevantes**:
    -   `Overall_Qual`, `Gr_Liv_Area`, `Garage_Cars`, `Garage_Area` y `Total_Bsmt_SF` muestran las correlaciones más fuertes con `Sale_Price`
    -   Se observan relaciones aproximadamente lineales con la variable respuesta
-   **Variables categóricas importantes**:
    -   `Neighborhood` muestra una gran variabilidad en los precios entre barrios
    -   `Overall_Qual` y `Kitchen_Qual` tienen una fuerte relación con el precio de venta
    -   La calidad de los materiales y el acabado (`Exter_Qual`, `Bsmt_Qual`) también son predictores importantes
-   **Valores faltantes**:
    -   Varias variables tienen valores faltantes que deberán ser manejados
    -   Algunas variables como `Pool_QC`, `Misc_Feature` y `Alley` tienen una alta proporción de valores faltantes
-   **Valores atípicos**:
    -   Se identificaron XX valores atípicos en `Sale_Price` (aproximadamente YY% de los datos)
    -   Estos valores podrían ser casas de lujo o errores de medición

### Recomendaciones para el modelado

-   **Preprocesamiento**:
    -   Aplicar transformación logarítmica a `Sale_Price` para manejar la asimetría
    -   Considerar la eliminación o imputación de variables con alta proporción de valores faltantes
    -   Estandarizar o normalizar las variables numéricas
    -   Codificar las variables categóricas (one-hot encoding o target encoding)
-   **Selección de características**:
    -   Incluir las variables más correlacionadas identificadas en el análisis
    -   Considerar la creación de características derivadas (ej: área total = área del primer piso + área del segundo piso)
    -   Evaluar la multicolinealidad entre predictores
-   **Validación del modelo**:
    -   Utilizar validación cruzada para una mejor estimación del rendimiento
    -   Considerar métricas robustas como el error absoluto mediano (MAE) además del RMSE
    -   Evaluar el rendimiento en diferentes rangos de precios
-   **Manejo de valores atípicos**:
    -   Evaluar el impacto de incluir/excluir valores atípicos
    -   Considerar modelos robustos a valores atípicos
-   **Consideraciones adicionales**:
    -   Evaluar interacciones entre variables (ej: efecto del barrio en la relación entre área y precio)
    -   Considerar efectos no lineales en las relaciones
    -   Evaluar la importancia de las variables en el modelo final

Este análisis proporciona una base sólida para el desarrollo de un modelo de regresión para predecir el precio de venta de viviendas. Se recomienda utilizar estos hallazgos para guiar las decisiones de preprocesamiento y selección de características en el modelo final.