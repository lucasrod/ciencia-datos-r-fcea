---
title: "Actividad Individual I"
subtitle: "Ciencia de Datos con R"
format: html
editor: visual
---

## Introducción

El objetivo de este trabajo es aplicar herramientas de **data wrangling** con `tidyverse` y realizar **visualizaciones** utilizando `ggplot2` y `plotly`.

------------------------------------------------------------------------

## Dataset: `gapminder` (incluido en `{gapminder}`)

El dataset `gapminder` del paquete `{gapminder}` contiene datos de desarrollo mundial de los paises entre los años 1952 y 2007, con información de todos los continentes.

### Variables principales:

-   `country`: país
-   `continent`: continente
-   `year`: año de observación
-   `lifeExp`: esperanza de vida
-   `pop`: población
-   `gdpPercap`: PBI per cápita

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(gapminder)
library(ggmosaic)
library(plotly)
library(testthat)

data(gapminder)
```

------------------------------------------------------------------------

### 1. Data Wrangling

1.1. Filtrar los países del continente asiático en el año 2007 con esperanza de vida mayor a 70 y PBI per cápita mayor a 5000; y luego calcula la mediana. Interprete el resultado. La mediana guardala en un nuevo objeto llamado `mediana`.

```{r}
#| label: ejercicio_11
mediana <- gapminder %>%
  filter(continent == "Asia", year == 2007, lifeExp > 70, gdpPercap > 5000) %>%
  summarise(mediana = median(lifeExp)) %>%
  pull(mediana)

mediana
```

1.2. Crear una nueva variable que represente el ingreso total (`gdpPercap * pop`) y visualizar la densidad del logaritmo de la variable creada. Obs: todo el proceso tiene que estar unido por pipes. Interprete la visualización obtenida. Guarde el gráfico en un objeto llamado `densidad_ingreso_total_log` y luego imprimalo.

```{r}
#| label: ejercicio_12

densidad_ingreso_total_log <- gapminder %>%
  mutate(
    ingreso_total = gdpPercap * pop,
    log_ingreso_total = log(ingreso_total)
  ) %>%
  filter(is.finite(log_ingreso_total)) %>%
  ggplot(aes(x = log_ingreso_total)) +
  geom_density(fill = "skyblue", alpha = 0.6) +
  labs(
    title = "Densidad del logaritmo del ingreso total",
    x = "log(ingreso_total)",
    y = "Densidad"
  ) +
  theme_minimal()

densidad_ingreso_total_log
```

1.3. Crear un nuevo data frame con las variables `country`, `year` y una variable categórica de esperanza de vida (baja \<menos de 50 años\>, media \<entre 50 y menos de 70 años\>, alta \<70 años o más\>). Luego, realizar la tabla de frecuencias de la variable categórica y la visualización de dicha tabla. La tabla de frecuencias almacenala en un objeto llamado `freq_exp_country_year` y la visualización en un objeto llamado `plot_freq_exp_country_year`

```{r}
#| label: ejercicio_13

# Proceso de categorización y visualización:
#
# 1. case_when() categoriza lifeExp en tres niveles usando puntos de corte fijos:
#    - baja: < 50 años
#    - media: entre 50 y 70 años
#    - alta: >= 70 años
#
# 2. count(exp_cat) genera la tabla de frecuencias requerida
#
# 3. ggplot crea gráfico de barras con:
#    - altura = frecuencia (n)
#    - color = categoría (exp_cat)
#    - estética minimalista (sin leyenda, ancho 0.6)

# Crear data frame con variable categórica de esperanza de vida
exp_cat_df <- gapminder %>%
  mutate(
    exp_cat = case_when(
      lifeExp < 50 ~ "baja",
      lifeExp >= 50 & lifeExp < 70 ~ "media",
      lifeExp >= 70 ~ "alta"
    )
  ) %>%
  select(country, year, exp_cat)

# Tabla de frecuencias
freq_exp_country_year <- exp_cat_df %>%
  count(exp_cat)

# Visualización de la tabla de frecuencias
library(ggplot2)
plot_freq_exp_country_year <- ggplot(freq_exp_country_year, aes(x = exp_cat, y = n, fill = exp_cat)) +
  geom_col(show.legend = FALSE, width = 0.6) +
  labs(
    title = "Frecuencia de categorías de esperanza de vida",
    x = "Categoría de esperanza de vida",
    y = "Frecuencia"
  ) +
  theme_minimal(base_size = 14)

plot_freq_exp_country_year
```

1.4. Usar `mutate(across())` para categorizar todas las variables numéricas en tres niveles: bajo, medio y alto. Observación: el objetivo es que cada categoria tenga aproximadamente las mismas cantidad de observaciones. El resultado debe ser un nuevo data.frame con las variables originales y las categorizadas. Guardar el nuevo data.frame en un objeto llamado `gapminder_cat`. Luego, visualizar la tabla de frecuencias de cada una de las variables categorizadas.

```{r}
#| label: ejercicio_14

# Explicación del proceso de categorización:
#
# 1. mutate(across()) permite aplicar una transformación a múltiples columnas:
#    - .cols = where(is.numeric) selecciona todas las columnas numéricas
#    - .fns define la función a aplicar (usando ~case_when para la categorización)
#    - .names = "cat_{.col}" genera nuevos nombres con prefijo "cat_"
#
# 2. ntile(., 3) divide los datos en tres grupos de igual tamaño:
#    - Asigna rangos y luego divide en terciles
#    - Garantiza grupos balanceados (~33% de observaciones cada uno)
#
# 3. La estructura resultante tendrá:
#    - Las variables originales intactas
#    - Nuevas variables categorizadas con prefijo "cat_"

# Crear data frame con variables originales y categorizadas
gapminder_cat <- gapminder %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~{
        breaks <- quantile(., probs = c(0, 1/3, 2/3, 1))
        cut(., 
            breaks = breaks,
            labels = c("bajo", "medio", "alto"),
            include.lowest = TRUE)
      },
      .names = "cat_{.col}"
    )
  )

# Proceso de visualización de frecuencias:
#
# 1. Identificar variables categorizadas:
#    - names(gapminder_cat) obtiene todos los nombres de columnas
#    - startsWith(..., "cat_") filtra solo las que empiezan con "cat_"
#    - Esto es necesario para separar las nuevas variables de las originales
#
# 2. Crear tablas de frecuencia usando map():
#    - map() aplica la misma función a cada variable categórica
#    - count() cuenta frecuencias por categoría
#    - mutate() agrega nombre de variable y calcula proporciones
#    - knitr::kable() formatea la tabla para mejor visualización

# Obtener nombres de variables categorizadas
var_categoricas <- names(gapminder_cat)[startsWith(names(gapminder_cat), "cat_")]

# Crear tabla de frecuencias con rangos para cada variable
walk(var_categoricas, ~{
  # Obtener nombre de la variable original (sin el prefijo cat_)
  var_original <- sub("cat_", "", .x)
  
  # Crear tabla de frecuencias con rangos por categoría
  gapminder_cat %>%
    group_by(.data[[.x]]) %>%
    summarise(
      categoria = first(.data[[.x]]),
      n = n(),
      valor_min = min(.data[[var_original]]),
      valor_max = max(.data[[var_original]]),
      .groups = "drop"
    ) %>%
  arrange(valor_min) %>%  # Ordenar por valor mínimo
  mutate(
    proporcion = n/sum(n),
    minimo = valor_min,
    maximo = valor_max
  ) %>%
  select(categoria, n, proporcion, minimo, maximo) %>%
  knitr::kable(
    caption = paste("Frecuencias y rangos para", var_original),
    col.names = c("Categoría", "Frecuencia", "Proporción", "Mínimo", "Máximo"),
    digits = 3
  ) %>%
  print()
})
```

1.5. Crear una variable `cat_pop` que clasifique los países según su población (`< 1 millón`, `1-10 millones`, `> 10 millones`). Remplaza el data.frame `gapminder_cat` por el nuevo data.frame que contiene la variable `cat_pop`.

```{r}
#| label: ejercicio_15
#| 
# Proceso de categorización por población:
#
# 1. Actualizar gapminder_cat manteniendo sus columnas y agregando cat_pop:
#    - Usar mutate() sobre el data.frame existente
#    - case_when() con umbrales de población en millones
#    - Mantener el orden lógico: menor a mayor población

# Actualizar data frame con nueva categorización de población
gapminder_cat <- gapminder_cat %>%
  mutate(
    cat_pop = case_when(
      pop < 1e6 ~ "< 1 millón",
      pop >= 1e6 & pop <= 1e7 ~ "1-10 millones",
      pop > 1e7 ~ "> 10 millones"
    )
  )

# Visualizar distribución de categorías de población
gapminder_cat %>%
  count(cat_pop) %>%
  mutate(prop = n/sum(n)) %>%
  knitr::kable(
    caption = "Distribución de países por categoría de población",
    col.names = c("Categoría", "Frecuencia", "Proporción"),
    digits = 3
  )
```

1.6. Seleccionar las variables que contengan la letra **c**. Luego, guardar el resultado en un nuevo objeto llamado `gapminder_c`.

```{r}
#| label: ejercicio_16
# Proceso de selección de variables:
#
# 1. Usar select() con matches():
#    - matches() busca patrones en nombres de columnas
#    - (?i)c hace la búsqueda insensible a mayúsculas/minúsculas
#    - Incluye tanto "c" como "C" en cualquier posición

# Seleccionar variables que contengan 'c' o 'C'
gapminder_c <- gapminder_cat %>%
  select(matches("(?i)c"))

# Mostrar nombres de variables seleccionadas
colnames(gapminder_c) %>%
  paste(collapse = ", ") %>%
  cat("Variables seleccionadas:\n", ., "\n")
```

1.7. Calcular el promedio y la desviación estándar de `lifeExp` y `gdpPercap` por continente y década. Guardar el resultado en un nuevo objeto llamado `summary_exp_continet_decade`

```{r}
#| label: ejercicio_17

# Proceso de cálculo de estadísticas por grupo:
#
# 1. Crear variable década a partir de year:
#    - floor(year/10)*10 redondea hacia abajo al inicio de década
#
# 2. Usar group_by() + summarise() para calcular estadísticas:
#    - Agrupar por continente y década
#    - Calcular media y desviación estándar para cada grupo

# Calcular estadísticas por continente y década
summary_exp_continet_decade <- gapminder %>%
  mutate(decada = floor(year/10)*10) %>%
  group_by(continent, decada) %>%
  summarise(
    lifeExp_mean = mean(lifeExp),
    lifeExp_sd = sd(lifeExp),
    gdpPercap_mean = mean(gdpPercap),
    gdpPercap_sd = sd(gdpPercap),
    .groups = "drop"
  )

# Mostrar resultados formateados
knitr::kable(
  summary_exp_continet_decade,
  caption = "Estadísticas por continente y década",
  digits = 2
)
```

1.8. Mostrar los 10 países con mayor esperanza de vida en 2007 usando `dplyr`. Calcula la media de la variable `gdpPercap` para dichos paises y comparala con la media global de `gdpPercap` para el año 2007. Comentar los resuktados obtenidos. El resultado con los promedios debe ser un nuevo data.frame llamado `summary_top10_exp`

```{r}
#| label: ejercicio_18

# Proceso de análisis:
#
# 1. Filtrar datos de 2007 y obtener top 10 por lifeExp
# 2. Calcular media de gdpPercap para:
#    - Los 10 países con mayor esperanza de vida
#    - Todos los países en 2007 (media global)

# Obtener top 10 países por esperanza de vida en 2007
top10_2007 <- gapminder %>%
  filter(year == 2007) %>%
  arrange(desc(lifeExp)) %>%
  slice_head(n = 10) %>%
  select(country, lifeExp, gdpPercap)

# Calcular medias y crear data frame resumen
summary_top10_exp <- gapminder %>%
  filter(year == 2007) %>%
  summarise(
    gdp_mean_global = mean(gdpPercap),
    gdp_mean_top10 = mean(top10_2007$gdpPercap),
    diff_porcentual = (gdp_mean_top10 - gdp_mean_global) / gdp_mean_global * 100
  )

# Mostrar top 10 países
knitr::kable(
  top10_2007,
  caption = "10 países con mayor esperanza de vida en 2007",
  col.names = c("País", "Esperanza de vida", "PIB per cápita"),
  digits = c(0, 2, 2)
)

# Mostrar comparación de medias
knitr::kable(
  summary_top10_exp,
  caption = "Comparación de PIB per cápita: Top 10 vs Global (2007)",
  col.names = c("Media global", "Media top 10", "Diferencia %"),
  digits = 2
)
```

**Análisis de resultados** Los 10 países con mayor esperanza de vida en 2007 tienen un PIB per cápita 186.4% superior a la media global. Esto sugiere una fuerte relación positiva entre el desarrollo económico y la longevidad de la población.

1.9. Realizar un `left_join()` entre `gapminder` y el siguiente tibble. El resultado almacenalo en un nuevo objeto llamado `gapminder_join`.

```{r}
region_labels <- tibble(
  continent = c("Africa", "Americas", "Asia", "Europe","Oceania"),
  region = c("África", "Américas", "Asia", "Europa", "Oceanía"))
```

```{r}
#| label: ejercicio_19

# Realizar left join entre gapminder y region_labels
gapminder_join <- gapminder %>%
  left_join(region_labels, by = "continent")

# Mostrar algunas filas del resultado
gapminder_join %>%
  group_by(region) %>%
  slice(1) %>%  # Una fila por región
  ungroup() %>%
  knitr::kable(caption = "Una fila por región para ilustrar variedad")
```

1.10. Mover la variable `pop` al inicio del dataset. El resultado almacenalo en un nuevo objeto llamado `gapminder_pop_first`.

```{r}
#| label: ejercicio_110
gapminder_pop_first <- gapminder %>%
  select(pop, everything())

head(gapminder_pop_first)
```

1.11. Extraer una muestra aleatoria de aproximadamente el 10% observaciones y comparar el promedio de `lifeExp` por continente con el de la base completa. El resultado de la muestra guardalo en `sample10_gapminder` Explicar de forma "intuitiva" porque existen diferencias

```{r}
#| label: ejercicio_111


```

1.12. Filtrar por el año 2007, crear una variable categórica de `gdpPercap` (al igual que lo realizado en el punto 1.4), agrupar por `continent` y categoría, y calcular el promedio de `lifeExp`. Guardar el resultado en un nuevo objeto llamado `summary_gdpPercap_lifeExp`.

```{r}
#| label: ejercicio_112


```

1.13. Estandarizar las variables `lifeExp`, `gdpPercap` y `pop` y luego calcular sus medias y desvíos estándar. Guardar el resultado en un nuevo objeto llamado `summary_estandarizado`.

```{r}
#| label: ejercicio_113


```

1.14. Calcular el cambio en esperanza de vida entre años (utilizar la función `lag`) para cada país y agrupar según si aumentó o no. Comparar el `gdpPercap` promedio en 2007 según esa clasificación. Guardar el resultado en un nuevo objeto llamado `summary_lifeExp_gdpPercap`.

```{r}
#| label: ejercicio_114

```

------------------------------------------------------------------------

## 2. Visualizaciones

Cada una de las visulizaciones debe tener: titulo, etiquetas en los ejes y todo aquello que consideres necesario para crear una buena visualización.

2.1. Gráfico de dispersión entre `gdpPercap` y `lifeExp`, coloreado por `continent`. Interpretar los resultados obtenidos.

```{r}
#| label: ejercicio_21


```

2.2. Boxplot de `lifeExp` por continente. Interpretar los resultados obtenidos

```{r}
#| label: ejercicio_22
```

2.3. Facet wrap de `gdpPercap` según año.

```{r}
#| label: ejercicio_23
```

2.4. Versión interactiva con `ggplotly()` del diagrama de dispersión realizado en el punto 2.1.

```{r}
#| label: ejercicio_24

```

2.5. Violin plot de `gdpPercap` por continente.

```{r}
#| label: ejercicio_25

```

2.6. Gráfico de mosaico de `continent` contra una categoría derivada de `lifeExp` (por ejemplo: baja, media, alta).

```{r}
#| label: ejercicio_26


```

------------------------------------------------------------------------

## Entrega

-   **La fecha limite de entrega es el 30 de abril de 2025.**

-   Las respuestas deben estar en este mismo archivo `.qmd`, el contenido deber ser completamente reproducible, es decir, cada chunk debe de funcionar sin errores para poder replicar los resultados.

-   No se aceptan archivos `.Rmd` o `.R` para la entrega. Solamente subir al repositorio el archivo `.qmd` con las respuestas.

-   Cada respuesta del ejercicio debe estar en el chunk correspondiente, no borrar la etiqueta del chunk `#| label: ejercicio_XX`.

-   Puede realizar pasos intermedios los que sean necesarios dentro del chunk pero debe de respetar el nombre del objeto final en el caso que se indique.

-   Los gráficos deben ser guardados en objetos y luego impresos en el caso que se indique que lo almacenen en un objeto. En el caso que no se indique, pueden ser impresos directamente.

-   Para comenzar la tarea deben de ir al siguiente link: [GitHub Classroom](https://classroom.github.com/a/g-XM7vb1). Una vez allí les va a pedir que indiquen su cuenta de GitHub y luego les va a crear un repositorio en su cuenta. Una vez creado el repositorio, deben de clonar el repositorio en su computadora y abrirlo con RStudio.

------------------------------------------------------------------------